// controllers/orderController.js
const Order = require('../models/Order');
const Product = require('../models/Product');
const User = require('../models/User');
const { safeNotify } = require('../utils/notificationMiddleware');
const assignOrderToNearestShipper = require('../utils/assignOrderToNearestShipper');
const { processOrderCompletionForFinance, reverseFinancialEntryForOrder } = require('./financeController');
const UserVoucher = require('../models/UserVoucher');
const Voucher = require('../models/Voucher'); // Th√™m model Voucher
const mongoose = require('mongoose');

// H√†m ki·ªÉm tra gi·ªù b√°n
const validateSaleTime = (product, nowMin) => {
    if (!product.saleStartTime || !product.saleEndTime) return true; // B√°n 24/7 n·∫øu kh√¥ng c√≥ gi·ªù
    const toMin = str => {
        const [h, m] = str.split(':').map(Number);
        return h * 60 + m;
    };
    const start = toMin(product.saleStartTime);
    const end = toMin(product.saleEndTime);
    return start <= end ? (nowMin >= start && nowMin <= end) : (nowMin >= start || nowMin <= end);
};

// H√†m g·ª≠i th√¥ng b√°o cho Admin
const notifyAdmins = async (order) => {
    const admins = await User.find({ role: 'admin', fcmToken: { $exists: true } });
    for (const admin of admins) {
        try {
            await safeNotify(admin.fcmToken, {
                title: 'üõí ƒê∆°n h√†ng m·ªõi',
                body: `#${order._id.toString().slice(-6)} t·ª´ ${order.customerName}: ${order.total.toLocaleString()}ƒë`,
                data: { orderId: order._id.toString(), shipperView: "true" }
            });
        } catch (e) {
            console.error(`[notify admin] error for admin ${admin._id}:`, e);
        }
    }
};

// ==============================================================================
// ===                      H√ÄM CREATE ORDER - PHI√äN B·∫¢N HO√ÄN CH·ªàNH          ===
// ==============================================================================
exports.createOrder = async (req, res) => {
    const session = await mongoose.startSession();
    session.startTransaction();
    try {
        const {
            items, total, phone, shippingAddress, shippingLocation, customerName,
            paymentMethod, shippingFee, extraSurcharge, voucherDiscount, voucherCode
        } = req.body;
        const userId = req.user._id;

        // --- 1. Validation c∆° b·∫£n ---
        if (!Array.isArray(items) || items.length === 0) {
            throw new Error('Gi·ªè h√†ng kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng');
        }
        if (!phone || !shippingAddress || !shippingLocation) {
            throw new Error('Thi·∫øu th√¥ng tin nh·∫≠n h√†ng');
        }

        const now = new Date();
        const nowMin = now.getHours() * 60 + now.getMinutes();
        const enrichedItems = [];

        // --- 2. X·ª≠ l√Ω v√† l√†m gi√†u th√¥ng tin cho t·ª´ng item ---
        for (const item of items) {
            const product = await Product.findById(item.productId).populate('seller').session(session);
            if (!product) throw new Error(`S·∫£n ph·∫©m "${item.name}" kh√¥ng c√≤n t·ªìn t·∫°i.`);
            if (!product.seller) throw new Error(`S·∫£n ph·∫©m "${product.name}" kh√¥ng c√≥ th√¥ng tin ng∆∞·ªùi b√°n.`);
            if (!validateSaleTime(product, nowMin)) {
                throw new Error(`S·∫£n ph·∫©m "${product.name}" ch·ªâ b√°n t·ª´ ${product.saleStartTime} ƒë·∫øn ${product.saleEndTime}.`);
            }

            let stock;
            if (product.variantTable && product.variantTable.length > 0) {
                const variant = product.variantTable.find(v => v.combination === item.combination);
                if (!variant) throw new Error(`Bi·∫øn th·ªÉ c·ªßa s·∫£n ph·∫©m "${item.name}" kh√¥ng t·ªìn t·∫°i.`);
                stock = variant.stock;
            } else {
                stock = product.stock;
            }
            if (stock < item.quantity) {
                throw new Error(`S·∫£n ph·∫©m "${product.name}" kh√¥ng ƒë·ªß h√†ng trong kho.`);
            }

            const itemTotal = item.price * item.quantity;
            const commissionRate = product.seller.commissionRate || 0;
            const commissionAmount = itemTotal * (commissionRate / 100);
            
            enrichedItems.push({
                ...item,
                sellerId: product.seller._id,
                commissionAmount: commissionAmount,
            });

            // Tr·ª´ kho
            if (product.variantTable && product.variantTable.length > 0) {
                const variantIndex = product.variantTable.findIndex(v => v.combination === item.combination);
                product.variantTable[variantIndex].stock -= item.quantity;
            } else {
                product.stock -= item.quantity;
            }
            await product.save({ session });
        }

        // --- 3. ƒê√ÅNH D·∫§U VOUCHER ƒê√É D√ôNG (N·∫æU C√ì) ---
        if (voucherCode && voucherDiscount > 0) {
            const voucher = await Voucher.findOne({ code: voucherCode.toUpperCase() }).session(session);
            if (!voucher) {
                throw new Error(`M√£ voucher "${voucherCode}" kh√¥ng t·ªìn t·∫°i.`);
            }

            const userVoucher = await UserVoucher.findOne({
                user: userId,
                voucher: voucher._id,
                isUsed: false
            }).session(session);

            if (!userVoucher) {
                throw new Error(`B·∫°n kh√¥ng s·ªü h·ªØu voucher "${voucherCode}" ho·∫∑c ƒë√£ s·ª≠ d·ª•ng n√≥.`);
            }

            userVoucher.isUsed = true;
            await userVoucher.save({ session });
        }

        // --- 4. T·∫°o ƒë∆°n h√†ng ---
        const order = new Order({
            user: userId,
            items: enrichedItems,
            total,
            customerName,
            phone,
            shippingAddress,
            shippingLocation,
            paymentMethod: paymentMethod || 'COD',
            shippingFee,
            extraSurcharge,
            voucherDiscount,
            voucherCode,
            status: 'Ch·ªù x√°c nh·∫≠n',
        });
        
        // D√πng create thay v√¨ new + save ƒë·ªÉ n√≥ tr·∫£ v·ªÅ m·ªôt m·∫£ng
        const [savedOrder] = await Order.create([order], { session });

        await session.commitTransaction();

        // C√°c h√†nh ƒë·ªông kh√¥ng quan tr·ªçng b·∫±ng c√≥ th·ªÉ ch·∫°y sau khi transaction th√†nh c√¥ng
        assignOrderToNearestShipper(savedOrder._id).catch(console.error);
        notifyAdmins(savedOrder);

        return res.status(201).json({
            message: 'T·∫°o ƒë∆°n th√†nh c√¥ng',
            order: { ...savedOrder.toObject(), timestamps: savedOrder.timestamps }
        });

    } catch (err) {
        await session.abortTransaction();
        console.error('L·ªói khi t·∫°o ƒë∆°n h√†ng:', err);
        const statusCode = err.message.includes('t·ªìn t·∫°i') || err.message.includes('ƒë·ªß h√†ng') || err.message.includes('voucher') ? 400 : 500;
        return res.status(statusCode).json({ message: err.message || 'L·ªói server' });
    } finally {
        session.endSession();
    }
};


// ==============================================================================
// ===                      C√ÅC H√ÄM KH√ÅC GI·ªÆ NGUY√äN                             ===
// ==============================================================================

exports.countByStatus = async (req, res) => {
  try {
    const counts = await Order.aggregate([ { $group: { _id: '$status', count: { $sum: 1 } } } ]).exec();
    const result = counts.reduce((acc, item) => { acc[item._id] = item.count; return acc; }, {});
    res.status(200).json(result);
  } catch (error) {
    res.status(500).json({ message: 'L·ªói server', error: error.message });
  }
};

exports.acceptOrder = async (req, res) => {
  try {
    const order = await Order.findById(req.params.id);
    if (!order) return res.status(404).json({ message: 'ƒê∆°n h√†ng kh√¥ng t·ªìn t·∫°i' });
    if (order.status !== 'Ch·ªù x√°c nh·∫≠n') return res.status(400).json({ message: 'ƒê∆°n kh√¥ng kh·∫£ d·ª•ng' });

    const shipper = await User.findById(req.user._id);
    if (!shipper || shipper.role !== 'shipper') {
      return res.status(403).json({ message: 'T√†i kho·∫£n kh√¥ng ph·∫£i l√† shipper.' });
    }

    // G√°n shipper v√† c·∫≠p nh·∫≠t tr·∫°ng th√°i
    order.status = 'ƒêang x·ª≠ l√Ω';
    order.shipper = shipper._id;
    order.timestamps.acceptedAt = new Date();

    // T√≠nh to√°n v√† l∆∞u thu nh·∫≠p cho shipper (gi·ªØ nguy√™n logic ƒë√£ s·ª≠a)
    const shareRate = (shipper.shipperProfile.shippingFeeShareRate || 0) / 100;
    const totalShippingFee = (order.shippingFee || 0) + (order.extraSurcharge || 0);
    const totalCommission = order.items.reduce((sum, item) => sum + (item.commissionAmount || 0), 0);
    const profitShareRate = (shipper.shipperProfile.profitShareRate || 0) / 100;
    order.shipperIncome = (totalShippingFee * shareRate) + (totalCommission * profitShareRate);
    order.financialDetails = {
        shippingFee: order.shippingFee,
        extraSurcharge: order.extraSurcharge,
        shippingFeeShareRate: shipper.shipperProfile.shippingFeeShareRate,
        profitShareRate: shipper.shipperProfile.profitShareRate
    };
    
    const updatedOrder = await order.save();

    // <<< LOGIC M·ªöI: G·ª¨I TH√îNG B√ÅO CHO SELLER V√Ä CUSTOMER >>>

    // 1. G·ª≠i th√¥ng b√°o cho kh√°ch h√†ng (Customer)
    const customer = await User.findById(order.user);
    if (customer?.fcmToken) {
        await safeNotify(customer.fcmToken, {
            title: 'Shipper ƒë√£ nh·∫≠n ƒë∆°n c·ªßa b·∫°n!',
            body: `ƒê∆°n h√†ng #${order._id.toString().slice(-6)} ƒëang ƒë∆∞·ª£c chu·∫©n b·ªã.`,
            data: { orderId: order._id.toString(), type: 'order_update' }
        });
    }

    // 2. T√¨m t·∫•t c·∫£ c√°c seller c√≥ s·∫£n ph·∫©m trong ƒë∆°n h√†ng
    const sellerIds = [...new Set(order.items.map(item => item.sellerId.toString()))];
    const sellers = await User.find({
        _id: { $in: sellerIds },
        fcmToken: { $exists: true, $ne: null }
    }).select('fcmToken');

    // 3. G·ª≠i th√¥ng b√°o cho t·ª´ng seller
    for (const seller of sellers) {
        await safeNotify(seller.fcmToken, {
            title: 'Shipper ƒë√£ nh·∫≠n ƒë∆°n h√†ng!',
            body: `ƒê∆°n h√†ng #${order._id.toString().slice(-6)} ƒë√£ c√≥ shipper nh·∫≠n. Vui l√≤ng chu·∫©n b·ªã h√†ng.`,
            data: { orderId: order._id.toString(), type: 'order_accepted_by_shipper' }
        });
    }
    // <<< K·∫æT TH√öC LOGIC M·ªöI >>>
    
    res.json({ message: 'Nh·∫≠n ƒë∆°n th√†nh c√¥ng', order: updatedOrder });
  } catch (error) {
    console.error('L·ªói khi ch·∫•p nh·∫≠n ƒë∆°n h√†ng:', error);
    res.status(500).json({ message: 'L·ªói server' });
  }
};

exports.updateOrderStatusByShipper = async (req, res) => {
  try {
    const { status, cancelReason } = req.body;
    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({ message: 'ƒê∆°n h√†ng kh√¥ng t·ªìn t·∫°i' });
    }
    if (!order.shipper || order.shipper.toString() !== req.user._id.toString()) {
      return res.status(403).json({ message: 'B·∫°n kh√¥ng ph·∫£i l√† shipper c·ªßa ƒë∆°n h√†ng n√†y.' });
    }

    const validTransitions = {
      'ƒêang x·ª≠ l√Ω': ['ƒêang giao', 'ƒê√£ hu·ª∑'],
      'ƒêang giao': ['ƒê√£ giao', 'ƒê√£ hu·ª∑']
    };

    if (!validTransitions[order.status]?.includes(status)) {
      return res.status(400).json({ message: `Kh√¥ng th·ªÉ chuy·ªÉn t·ª´ tr·∫°ng th√°i "${order.status}" sang "${status}".` });
    }

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i v√† th·ªùi gian
    order.status = status;
    const now = new Date();

    if (status === 'ƒêang giao') {
      order.timestamps.deliveringAt = now;
    } else if (status === 'ƒê√£ giao') {
      order.timestamps.deliveredAt = now;
    } else if (status === 'ƒê√£ hu·ª∑') {
      order.timestamps.canceledAt = now;
      order.cancelReason = cancelReason || 'Shipper ƒë√£ h·ªßy ƒë∆°n';
    }

    // L∆∞u c√°c thay ƒë·ªïi v·ªÅ tr·∫°ng th√°i v√† th·ªùi gian v√†o DB
    const updatedOrder = await order.save();
    
    // <<< LOGIC ƒê√öNG: CH·ªà X·ª¨ L√ù T√ÄI CH√çNH SAU KHI ƒê∆†N H√ÄNG ƒê√É TH·ª∞C S·ª∞ L√Ä "ƒê√É GIAO" >>>
    if (status === 'ƒê√£ giao') {
        // G·ªçi h√†m x·ª≠ l√Ω t√†i ch√≠nh m·ªôt c√°ch an to√†n
        // D√πng `await` ƒë·ªÉ ƒë·∫£m b·∫£o n√≥ ch·∫°y xong tr∆∞·ªõc khi g·ª≠i response
        await processOrderCompletionForFinance(updatedOrder._id);
    }

    // G·ª≠i th√¥ng b√°o cho kh√°ch h√†ng (n·∫øu c√≥)

    res.json({ message: 'C·∫≠p nh·∫≠t tr·∫°ng th√°i th√†nh c√¥ng', order: updatedOrder });
  } catch (error) {
    console.error(`L·ªói khi shipper c·∫≠p nh·∫≠t tr·∫°ng th√°i:`, error);
    res.status(500).json({ message: 'L·ªói server' });
  }
};

exports.getShipperOrders = async (req, res) => {
  try {
    const { status, page = 1, limit = 10 } = req.query;
    const result = await Order.paginate({ shipper: req.user._id, ...(status && { status }) }, { page: parseInt(page), limit: parseInt(limit), sort: { createdAt: -1 } });
    res.json({ orders: result.docs.map(doc => ({ ...doc.toObject(), timestamps: doc.timestamps })), totalPages: result.totalPages, currentPage: result.page, totalOrders: result.totalDocs });
  } catch (error) {
    res.status(500).json({ message: 'L·ªói server' });
  }
};

exports.getMyOrders = async (req, res) => {
  try {
    const { status, page = 1, limit = 10 } = req.query;
    const result = await Order.paginate({ user: req.user._id, ...(status && { status }) }, { page, limit, sort: { createdAt: -1 } });
    res.json({ docs: result.docs.map(doc => ({ ...doc.toObject(), timestamps: doc.timestamps })), totalPages: result.totalPages, page: result.page });
  } catch (err) {
    res.status(500).json({ message: 'L·ªói server' });
  }
};

exports.countOrdersByStatus = async (req, res) => {
  try {
    if (!req.user || !req.user._id) {
      return res.status(401).json({ message: 'Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá' });
    }

    // S·ª≠ d·ª•ng aggregate ƒë·ªÉ t·ªëi ∆∞u v√† ch√≠nh x√°c h∆°n
    const counts = await Order.aggregate([
      { $match: { user: req.user._id } }, // Ch·ªâ t√¨m ƒë∆°n c·ªßa user ƒëang ƒëƒÉng nh·∫≠p
      { $group: { _id: '$status', count: { $sum: 1 } } }
    ]);

    // Chuy·ªÉn ƒë·ªïi k·∫øt qu·∫£ v·ªÅ ƒë√∫ng ƒë·ªãnh d·∫°ng m√† frontend mong ƒë·ª£i
    const result = {
        pending: 0,
        confirmed: 0,
        shipped: 0,
        delivered: 0,
        canceled: 0
    };

    counts.forEach(item => {
        if (item._id === 'Ch·ªù x√°c nh·∫≠n') result.pending = item.count;
        if (item._id === 'ƒêang x·ª≠ l√Ω') result.confirmed = item.count;
        if (item._id === 'ƒêang giao') result.shipped = item.count;
        if (item._id === 'ƒê√£ giao') result.delivered = item.count;
        if (item._id === 'ƒê√£ hu·ª∑') result.canceled = item.count;
    });

    res.status(200).json(result);

  } catch (err) {
    console.error('[countOrdersByStatus] L·ªói:', err);
    return res.status(500).json({ message: 'L·ªói server khi ƒë·∫øm ƒë∆°n h√†ng' });
  }
};

exports.getOrderById = async (req, res) => {
  try {
    const order = await Order.findById(req.params.id)
      .populate('user', 'name phone') // L·∫•y t√™n v√† SƒêT c·ªßa kh√°ch h√†ng
      .populate('shipper', 'name phone shipperProfile.vehicleType shipperProfile.licensePlate'); // L·∫•y th√¥ng tin c·ªßa shipper

    if (!order) {
      return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng' });
    }

    let canView = false;
    const currentUserId = req.user._id;
    const currentUserRole = req.user.role;

    if (currentUserRole === 'admin') canView = true;
    else if (order.user?._id.equals(currentUserId)) canView = true;
    else if (order.shipper?._id.equals(currentUserId)) canView = true;
    else if (currentUserRole === 'shipper' && order.status === 'Ch·ªù x√°c nh·∫≠n') canView = true;
    else if (currentUserRole === 'seller' && order.items.some(item => item.sellerId.equals(currentUserId))) canView = true;
    
    if (canView) {
      let responseOrder = order.toObject({ virtuals: true });
      responseOrder.timestamps = order.timestamps;
      
      // Kh√¥ng c·∫ßn x√≥a th√¥ng tin n·ªØa, v√¨ frontend s·∫Ω t·ª± quy·∫øt ƒë·ªãnh hi·ªÉn th·ªã g√¨
      res.json(responseOrder);
    } else {
      res.status(403).json({ message: 'B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p ƒë∆°n h√†ng n√†y.' });
    }

  } catch (err) {
    console.error('[getOrderById] error:', err);
    res.status(500).json({ message: err.message || 'L·ªói server' });
  }
};


exports.getAllOrders = async (req, res) => {
  try {
    const { status, page = 1, limit = 10 } = req.query;
    const query = status ? { status } : {};

    // <<< S·ª¨A ƒê·ªîI: Th√™m `sort` ƒë·ªÉ s·∫Øp x·∫øp ƒë∆°n h√†ng m·ªõi nh·∫•t l√™n ƒë·∫ßu >>>
    const options = {
      page: parseInt(page, 10),
      limit: parseInt(limit, 10),
      sort: { 'timestamps.createdAt': -1 }, 
      populate: {
        path: 'user',
        select: 'name' // Ch·ªâ l·∫•y t√™n user cho g·ªçn
      },
    };

    const result = await Order.paginate(query, options);
    
    res.json({
      docs: result.docs.map(doc => ({ ...doc.toObject(), timestamps: doc.timestamps })),
      totalPages: result.totalPages,
      page: result.page
    });
  } catch (err) {
    console.error('[getAllOrders] error:', err);
    res.status(500).json({ message: 'L·ªói server khi l·∫•y t·∫•t c·∫£ ƒë∆°n h√†ng' });
  }
};

exports.updateOrderStatus = async (req, res) => {
  try {
    const { status, cancelReason } = req.body; // Th√™m cancelReason
    if (!status) {
      return res.status(400).json({ message: 'Thi·∫øu th√¥ng tin tr·∫°ng th√°i m·ªõi' });
    }

    const order = await Order.findById(req.params.id);
    if (!order) {
      return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng' });
    }

    const oldStatus = order.status; // L∆∞u l·∫°i tr·∫°ng th√°i c≈© ƒë·ªÉ so s√°nh
    order.status = status;
    const now = new Date();

    switch (status) {
      case 'ƒêang x·ª≠ l√Ω':
        if (!order.timestamps.acceptedAt) order.timestamps.acceptedAt = now;
        break;
      case 'ƒêang giao':
        if (!order.timestamps.deliveringAt) order.timestamps.deliveringAt = now;
        break;
      case 'ƒê√£ giao':
        if (!order.timestamps.deliveredAt) {
          order.timestamps.deliveredAt = now;
          await processOrderCompletionForFinance(order._id);
        }
        break;
      case 'ƒê√£ hu·ª∑':
        if (!order.timestamps.canceledAt) {
          order.timestamps.canceledAt = now;
          const reason = cancelReason || 'Admin ƒë√£ h·ªßy ƒë∆°n';
          order.cancelReason = reason;

          // <<< LOGIC M·ªöI: KI·ªÇM TRA V√Ä ƒê·∫¢O NG∆Ø·ª¢C GIAO D·ªäCH >>>
          // Ch·ªâ ƒë·∫£o ng∆∞·ª£c n·∫øu tr·∫°ng th√°i c≈© l√† "ƒê√£ giao"
          if (oldStatus === 'ƒê√£ giao') {
            await reverseFinancialEntryForOrder(order._id, reason);
          }
        }
        break;
    }

    const updatedOrder = await order.save();
    
    res.json({
      message: 'C·∫≠p nh·∫≠t tr·∫°ng th√°i th√†nh c√¥ng',
      order: updatedOrder
    });

  } catch (err) {
    console.error('[updateOrderStatus by Admin] error:', err);
    res.status(500).json({ message: err.message || 'L·ªói server khi c·∫≠p nh·∫≠t tr·∫°ng th√°i' });
  }
};

exports.cancelOrder = async (req, res) => {
  try {
    const query = req.user.isAdmin ? { _id: req.params.id } : { _id: req.params.id, user: req.user._id };
    const order = await Order.findOne(query);
    if (!order) return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng' });
    if (order.status !== 'Ch·ªù x√°c nh·∫≠n') return res.status(400).json({ message: 'Ch·ªâ h·ªßy ƒë∆∞·ª£c ƒë∆°n ch∆∞a x·ª≠ l√Ω' });
    order.status = 'ƒê√£ hu·ª∑';
    order.timestamps.canceledAt = new Date();
    const updated = await order.save();
    res.json({ message: 'Hu·ª∑ ƒë∆°n th√†nh c√¥ng', order: updated });
  } catch (err) {
    res.status(err.name === 'CastError' ? 400 : 500).json({ message: err.message || 'L·ªói server' });
  }
};

exports.adminCountByStatus = async (req, res) => {
  try {
    const counts = await Order.aggregate([
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 }
        }
      }
    ]);

    const result = {
        'pending': 0,
        'confirmed': 0,
        'shipped': 0,
        'delivered': 0,
        'canceled': 0
    };

    counts.forEach(item => {
        // √Ånh x·∫° t·ª´ t√™n tr·∫°ng th√°i trong DB sang key m√† frontend mong ƒë·ª£i
        if (item._id === 'Ch·ªù x√°c nh·∫≠n') result.pending = item.count;
        if (item._id === 'ƒêang x·ª≠ l√Ω') result.confirmed = item.count;
        if (item._id === 'ƒêang giao') result.shipped = item.count;
        if (item._id === 'ƒê√£ giao') result.delivered = item.count;
        if (item._id === 'ƒê√£ hu·ª∑') result.canceled = item.count;
    });

    res.status(200).json(result);
  } catch (error) {
    console.error('[adminCountByStatus] L·ªói:', error);
    res.status(500).json({ message: 'L·ªói server khi ƒë·∫øm ƒë∆°n h√†ng' });
  }
};
